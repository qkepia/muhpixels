//-----------------------------------------------------------------------------------------------// 
// FrameBuf.h
//-----------------------------------------------------------------------------------------------// 
#ifndef MPX_BASE_FRAME_BUF_H
#define MPX_BASE_FRAME_BUF_H

#include <vector>

//------------------------------------------------------------------------------------------------//

namespace mpx {

//------------------------------------------------------------------------------------------------//
// Buffer for frame data.
//------------------------------------------------------------------------------------------------//
template<typename T>
class FrameBuf
{
public:
	FrameBuf() = default;

	FrameBuf(int width, int height) 
		: m_data(width * height)
		, m_width(width)
		, m_height(height) 
	{}

	// todo: can we use the autogenerated one in VS2013 now?
	FrameBuf(FrameBuf&& other)
		: m_data(std::move(other.m_data))
		, m_width(other.m_width)
		, m_height(other.m_height)		
	{}

	FrameBuf& operator=(FrameBuf other)
	{
		std::swap(m_data, other.m_data);
		m_width = other.m_width;
		m_height = other.m_height;		
		return *this;
	}

	const T* data() const 
	{ 
		return m_data.data();
	}
		
	T* data()
	{ 
		return m_data.data();
	}

	const T* begin() const
	{
		return m_data.data()
	}

	T* begin()
	{
		return m_data.data()
	}

	const T* end() const
	{
		return m_data.data() + m_data.size();
	}

	T* end()
	{
		return m_data.data() + m_data.size();
	}

	const T& operator[](int i) const
	{
		return m_data[i];
	}

	T& operator[](int i)
	{
		return m_data[i];
	}

	const T& operator()(int x, int y) const 
	{ 
		return m_data[y * m_width + x]; 
	}
		
	T& operator()(int x, int y) 
	{
		return m_data[y * m_width + x]; 
	}

	int index(int x, int y) const
	{
		return y * m_width + x;
	}
	
	int width() const 
	{ 
		return m_width; 
	}

	int height() const 
	{ 
		return m_height; 
	}

	int size() const
	{
		return int(m_data.size());
	}

	void setSize(int width, int height) 
	{ 
		m_width = width;
		m_height = height;
		m_data.resize(width * height);
	}

private:
	std::vector<T> m_data;
	int m_width = 0;
	int m_height = 0;
};

//------------------------------------------------------------------------------------------------//

} // mpx

//------------------------------------------------------------------------------------------------//

#endif
